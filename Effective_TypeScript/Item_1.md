### TS와 JS의 관계 이해하기
- TS는 JS의 상위 집합이다. ( <==> JS는 TS의 부분 집합이다.)
- TS는 JS의 런타임 동작을 모델링하는 타입 시스템을 가지고 있고, 런타임 오류를 발생시킬 수 있는 코드를 컴파일 타임에 찾으려고 한다.
- 타입 체커를 통과하여도 JS 런타임에 오류를 발생시키는 코드는 얼마든지 존재할 수 있다.

### 더 알아보기 

### TypeScript의 JavaScript 런타임 모델링
- **JS가 실제로 어떻게 움직이는지(값의 종류, 분기, 예외 케이스, API 존재 여부)**를 바탕으로, 컴파일 시점에 “그럴듯하게” 추론하고 경고하는 정적 모델을 만든다는 뜻

1. **`tsconfig.json` 파일을 찾아 `프로젝트`를 결정 및 `타입체크/emit` 규칙 결정**

2. **<b>`Program` 객체 생성</b> : 컴파일 전체를 대표하는 `컴파일 세션` 만들기**
    - `Program`객체?: 해당 컴파일 세션에서 다룰 소스 파일들 + 옵션 + 파일 시스템 접근 방식(Host)의 묶음
    - `ts.createProgram(fileNames, options)`로 Program 생성, `program.emit()`으로 결과 출력
    - 또한 `createProgram`메서드로 파일 시스템 접근을 `CompilerHost`로 추상화한다고 명시 되어 있다.. 기본 Host는 디스크에서 파일을 읽어옴
 
3. **파일 읽기: `텍스트를 메모리로 로드`**

4. **스캐너(lexer): 텍스트 -> 토큰 스트림**
   - 스캐너가 문자들을 훑어 토큰 스트림으로 만든다. (ex. `identifier`,`keyword`,`{`,`}`,`=>`,`string literal`)
 
5. **파서(parser): `토큰 스트림 -> AST(구문 트리)`**
   - 파서가 스캐너를 제어하며 syntax 토큰 스트림을 소비하고, AST를 생성
   - 이 시점에 주로 검출하는 오류는 `문법이 말이 되는가?(syntax errors)`
 
6. **바인더(binders): AST의 선언들 -> 심볼(Symbol)과 스코프(Scope)**
   - 바인더는 AST를 순회하며 선언을 만나면 
     - 각 선언마다 `Symbol`을 만들고 
     - 현재 스코프(함수/블록/모듈 파일 등)의 `SymbolTable`에 저장
     - 이 `Symbol`덕분에 체커가 이름을 찾아가며 타입을 판단할 수 있다.
   - TS의 타입체크는 `이 식별자 이름이 어느 선언을 가리키는가`를 알아야 시작할 수 있기 때문에 이 단계가 **중요**
   
7. **체커(TypeChecker): 심볼/AST 기반으로 타입 관계를 계산 후 진짜 오류 검출**
   - `TypeChecker`는 `Program`객체로부터 만들 수 있고, TS 타입 시스템의 핵심이다.
   - 여러 파일의 심볼 관계를 계산하고, 심볼에 타입을 할당하고 semantic diagnotics(의미/타입 오류)를 생성한다.

8. **이미터(emitter): AST -> 출력 파일(.js / .d.ts / .map)**
   - AST를 훑으며 소스 코드를 출력하는 `트리 기반 Emitter`
   - 주어진 AST를 출력하는 것에 집중하는 컴포넌트
   - 즉, `Emit이 이상하다`는 문제는 상당수가 `Emit 로직`이 아니라 앞서 만들어진 `AST/심볼/타입`정보가 기대와 다르게 구성된 것일 확률이 높다.

9. **(Optional) 증분 빌드: 다음 컴파일을 빠르게 하기 위한 캐시 저장**
   - `incremental: true`설정을 하면, TS는 이전 빌드 정보를 `*.tsbuildinfo` 파일로 저장한다.
   - 이 파일을 사용하여 `incrementally type-check and update outputs files` == `전체 코드를 매번 다시 컴파일하지 않고, 변경된 부분만 타입 검사 수행 후, 그 결과물을 업데이트`